import { AlgorithmPattern } from '@algo-trainer/shared/types/algorithm-types';

export const triePattern: AlgorithmPattern = {
  title: "Trie Data Structure",
  description:
    "A tree-like data structure used to store a dynamic set of strings, commonly used for efficient prefix-based operations.",
  timeComplexity: "O(m) for insertion and search, where m is the length of the string",
  spaceComplexity: "O(ALPHABET_SIZE * m * n), where n is the number of strings",
  pseudocode: `1. Define a TrieNode class with children and isEndOfWord flag\n2. Insert:\n   a. For each character in the string:\n      - If the character is not in the current node's children, create a new node\n      - Move to the child node\n   b. Mark the last node as the end of a word\n3. Search:\n   a. For each character in the string:\n      - If the character is not in the current node's children, return false\n      - Move to the child node\n   b. Return true if the last node is marked as the end of a word\n4. Delete:\n   a. Recursively delete nodes if they have no children and are not the end of a word\n   b. Mark the last node as not the end of a word`,
  example: `Insert: "cat", "car", "dog"\n\nTrie Structure:\n    root\n   /    \\\n  c      d\n /       \\\na         o\n|         \\\nt          g\n|\nr\n\nSearch: "cat" -> true\nSearch: "car" -> true\nSearch: "dog" -> true\nSearch: "ca" -> false\nSearch: "cats" -> false`,
  implementation: `class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEndOfWord = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEndOfWord = True\n    \n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.isEndOfWord\n    \n    def delete(self, word):\n        def delete_helper(node, word, depth):\n            if depth == len(word):\n                if not node.isEndOfWord:\n                    return False\n                node.isEndOfWord = False\n                return len(node.children) == 0\n            \n            char = word[depth]\n            if char not in node.children:\n                return False\n            \n            should_delete_current_node = delete_helper(node.children[char], word, depth + 1)\n            \n            if should_delete_current_node:\n                del node.children[char]\n                return len(node.children) == 0\n            \n            return False\n        \n        delete_helper(self.root, word, 0)`,
  category: "Data Structures",
};
