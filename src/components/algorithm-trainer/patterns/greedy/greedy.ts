import { AlgorithmPattern } from "../../types";

export const greedyPattern: AlgorithmPattern = {
  title: "Greedy Algorithm",
  description:
    "A problem-solving approach that makes the locally optimal choice at each step, hoping that these choices will lead to a globally optimal solution.",
  timeComplexity:
    "Varies by algorithm, typically O(n log n) for sorting-based greedy algorithms",
  spaceComplexity: "Varies by algorithm, typically O(1) to O(n)",
  pseudocode: `1. Identify if the problem can be solved using a greedy approach:\n   a. The problem has optimal substructure (optimal solution contains optimal solutions to subproblems)\n   b. The problem has the greedy choice property (locally optimal choice leads to globally optimal solution)\n2. Determine the criteria for making the greedy choice\n3. Sort the input if necessary (often required for greedy algorithms)\n4. Iterate through the sorted input, making the greedy choice at each step\n5. Return the solution\n6. Prove the correctness of the algorithm (if possible)`,
  example: `Problem: Fractional Knapsack\n\nGiven:\n- A set of items, each with a weight and value\n- A knapsack with a maximum weight capacity\n- Items can be broken into smaller pieces\n\nGreedy Approach:\n1. Calculate the value per unit weight for each item\n2. Sort items by value per unit weight in descending order\n3. Take as much of each item as possible, starting with the highest value per unit weight\n\nExample:\nItems: [(10, 60), (20, 100), (30, 120)]  # (weight, value)\nCapacity: 50\n\nValue per unit weight:\nItem 1: 60/10 = 6\nItem 2: 100/20 = 5\nItem 3: 120/30 = 4\n\nSorted order: Item 1, Item 2, Item 3\n\nSolution:\nTake all of Item 1 (10 units)\nTake all of Item 2 (20 units)\nTake 2/3 of Item 3 (20 units)\n\nTotal value = 60 + 100 + (2/3 * 120) = 240`,
  implementation: `# Fractional Knapsack implementation using greedy approach\ndef fractional_knapsack(items, capacity):\n    # Calculate value per unit weight and sort items\n    items_with_value = [(w, v, v/w) for w, v in items]\n    items_with_value.sort(key=lambda x: x[2], reverse=True)\n    \n    total_value = 0\n    remaining_capacity = capacity\n    \n    for weight, value, _ in items_with_value:\n        if remaining_capacity >= weight:\n            # Take the whole item\n            total_value += value\n            remaining_capacity -= weight\n        else:\n            # Take a fraction of the item\n            fraction = remaining_capacity / weight\n            total_value += value * fraction\n            break\n    \n    return total_value\n\n# Example usage\nitems = [(10, 60), (20, 100), (30, 120)]  # (weight, value)\ncapacity = 50\nresult = fractional_knapsack(items, capacity)\nprint(f"Maximum value: {result}")`,
};
