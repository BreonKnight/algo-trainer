import { AlgorithmPattern } from "../../types";

export const graphPattern: AlgorithmPattern = {
  title: "Graph Algorithm",
  description:
    "A collection of algorithms for solving problems involving graphs, which are data structures consisting of vertices (nodes) and edges (connections between nodes).",
  timeComplexity:
    "Varies by algorithm, typically O(V + E) for graph traversal where V is the number of vertices and E is the number of edges",
  spaceComplexity: "Varies by algorithm, typically O(V) to O(V + E) for graph algorithms",
  pseudocode: `1. Identify the graph problem type:\n   a. Graph traversal (visiting all vertices)\n   b. Shortest path finding (finding the shortest path between vertices)\n   c. Cycle detection (detecting cycles in the graph)\n   d. Connected components (finding groups of connected vertices)\n2. Choose the appropriate graph algorithm based on the problem\n3. Implement the chosen algorithm\n4. Analyze the time and space complexity of the algorithm`,
  example: `Graph:\nA -- B -- C\n|    |    |\nD -- E -- F\n\n1. Graph Traversal:\n   - DFS starting from A: A, B, C, F, E, D\n   - BFS starting from A: A, B, D, C, E, F\n\n2. Shortest Path:\n   - Shortest path from A to F: A, B, C, F (length 3)\n\n3. Cycle Detection:\n   - Detected cycle: A, B, E, D, A\n\n4. Connected Components:\n   - All vertices are in one connected component`,
  implementation: `# Graph representation using adjacency list\nclass Graph:\n    def __init__(self):\n        self.graph = {}\n\n    def add_vertex(self, vertex):\n        if vertex not in self.graph:\n            self.graph[vertex] = []\n\n    def add_edge(self, vertex1, vertex2):\n        if vertex1 not in self.graph:\n            self.add_vertex(vertex1)\n        if vertex2 not in self.graph:\n            self.add_vertex(vertex2)\n        self.graph[vertex1].append(vertex2)\n        self.graph[vertex2].append(vertex1)  # For undirected graph\n\n    def dfs(self, start, visited=None):\n        if visited is None:\n            visited = set()\n        visited.add(start)\n        print(start, end=' ')\n        for neighbor in self.graph[start]:\n            if neighbor not in visited:\n                self.dfs(neighbor, visited)\n\n    def bfs(self, start):\n        visited = set()\n        queue = [start]\n        visited.add(start)\n        while queue:\n            vertex = queue.pop(0)\n            print(vertex, end=' ')\n            for neighbor in self.graph[vertex]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n\n    def has_cycle(self):\n        visited = set()\n        for vertex in self.graph:\n            if vertex not in visited:\n                if self._has_cycle_util(vertex, visited, None):\n                    return True\n        return False\n\n    def _has_cycle_util(self, vertex, visited, parent):\n        visited.add(vertex)\n        for neighbor in self.graph[vertex]:\n            if neighbor not in visited:\n                if self._has_cycle_util(neighbor, visited, vertex):\n                    return True\n            elif parent != neighbor:\n                return True\n        return False\n\n    def connected_components(self):\n        visited = set()\n        components = []\n        for vertex in self.graph:\n            if vertex not in visited:\n                component = []\n                self._dfs_util(vertex, visited, component)\n                components.append(component)\n        return components\n\n    def _dfs_util(self, vertex, visited, component):\n        visited.add(vertex)\n        component.append(vertex)\n        for neighbor in self.graph[vertex]:\n            if neighbor not in visited:\n                self._dfs_util(neighbor, visited, component)\n\n# Example usage\ng = Graph()\ng.add_edge('A', 'B')\ng.add_edge('B', 'C')\ng.add_edge('C', 'F')\ng.add_edge('A', 'D')\ng.add_edge('B', 'E')\ng.add_edge('D', 'E')\ng.add_edge('E', 'F')\n\nprint("DFS starting from A:")\ng.dfs('A')\nprint("\\nBFS starting from A:")\ng.bfs('A')\nprint("\\nHas cycle:", g.has_cycle())\nprint("Connected components:", g.connected_components())\n`,
  category: "Graph",
};
