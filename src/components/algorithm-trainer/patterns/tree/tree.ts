import { AlgorithmPattern } from "../../types";

export const treePattern: AlgorithmPattern = {
  title: "Tree Algorithm",
  description:
    "A collection of algorithms for solving problems involving trees, which are hierarchical data structures consisting of nodes connected by edges.",
  timeComplexity:
    "Varies by algorithm, typically O(n) for traversal algorithms where n is the number of nodes",
  spaceComplexity:
    "Varies by algorithm, typically O(h) for recursive algorithms where h is the height of the tree",
  pseudocode: `1. Define the tree node structure (value, left child, right child)\n2. Choose the appropriate tree algorithm based on the problem:\n   a. Traversal algorithms (inorder, preorder, postorder) for visiting all nodes\n   b. Tree construction algorithms for building trees from various inputs\n   c. Tree manipulation algorithms for modifying tree structure\n   d. Tree property algorithms for checking properties like height, balance, etc.\n3. Implement the chosen algorithm\n4. Analyze the time and space complexity of the algorithm`,
  example: `Tree Structure:\n     1\n   /   \\\n  2     3\n / \\   / \\\n4   5 6   7\n\nTree Traversals:\n\n1. Inorder Traversal (Left, Root, Right):\n   - Traverse left subtree\n   - Visit root\n   - Traverse right subtree\n   - Result: 4, 2, 5, 1, 6, 3, 7\n\n2. Preorder Traversal (Root, Left, Right):\n   - Visit root\n   - Traverse left subtree\n   - Traverse right subtree\n   - Result: 1, 2, 4, 5, 3, 6, 7\n\n3. Postorder Traversal (Left, Right, Root):\n   - Traverse left subtree\n   - Traverse right subtree\n   - Visit root\n   - Result: 4, 5, 2, 6, 7, 3, 1\n\n4. Level Order Traversal (BFS):\n   - Visit nodes level by level\n   - Result: 1, 2, 3, 4, 5, 6, 7`,
  implementation: `# Tree node definition\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n# Inorder traversal\ndef inorder_traversal(root):\n    result = []\n    \n    def inorder(node):\n        if not node:\n            return\n        inorder(node.left)\n        result.append(node.val)\n        inorder(node.right)\n    \n    inorder(root)\n    return result\n\n# Preorder traversal\ndef preorder_traversal(root):\n    result = []\n    \n    def preorder(node):\n        if not node:\n            return\n        result.append(node.val)\n        preorder(node.left)\n        preorder(node.right)\n    \n    preorder(root)\n    return result\n\n# Postorder traversal\ndef postorder_traversal(root):\n    result = []\n    \n    def postorder(node):\n        if not node:\n            return\n        postorder(node.left)\n        postorder(node.right)\n        result.append(node.val)\n    \n    postorder(root)\n    return result\n\n# Level order traversal (BFS)\ndef level_order_traversal(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = [root]\n    \n    while queue:\n        level_size = len(queue)\n        level = []\n        \n        for _ in range(level_size):\n            node = queue.pop(0)\n            level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(level)\n    \n    return result\n\n# Example usage\n# Create a sample tree\n#     1\n#   /   \\\n#  2     3\n# / \\   / \\\n#4   5 6   7\n\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left.left = TreeNode(4)\nroot.left.right = TreeNode(5)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(7)\n\nprint("Inorder traversal:", inorder_traversal(root))\nprint("Preorder traversal:", preorder_traversal(root))\nprint("Postorder traversal:", postorder_traversal(root))\nprint("Level order traversal:", level_order_traversal(root))`,
};
