import { AStarSearchPattern } from "./patterns/a-star-search";
import { ArticulationPointsPattern } from "./patterns/articulation-points";
import { AVLTreePattern } from "./patterns/avl-tree";
import { BacktrackingPattern } from "./patterns/backtracking";
import { BellmanFordPattern } from "./patterns/bellman-ford";
import { BFSPattern } from "./patterns/bfs";
import { BfsLinkedListPattern } from "./patterns/bfs-linked-list";
import { BinarySearchOnAnswerPattern } from "./patterns/binary-search-on-answer";
import { BinarySearchPattern } from "./patterns/binary-search";
import { BinarySearchTreePattern } from "./patterns/binary-search-tree";
import { BitManipulationPattern } from "./patterns/bit-manipulation";
import { BTreePattern } from "./patterns/b-tree";
import { BubbleSortPattern } from "./patterns/bubble-sort";
import { ChineseRemainderTheoremPattern } from "./patterns/chinese-remainder-theorem";
import { CircularLinkedListPattern } from "./patterns/circular-linked-list";
import { DFSPattern } from "./patterns/dfs";
import { DfsBinaryTreePattern } from "./patterns/dfs-binary-tree";
import { DfsLinkedListPattern } from "./patterns/dfs-linked-list";
import { DigitDPPattern } from "./patterns/digit-dp";
import { DivideAndConquerPattern } from "./patterns/divide-and-conquer";
import { DynamicProgrammingCoinChangePattern } from "./patterns/dynamic-programming-coin-change";
import { DynamicProgrammingIterativePattern } from "./patterns/dynamic-programming-iterative";
import { DynamicProgrammingPattern } from "./patterns/dynamic-programming";
import { DynamicProgrammingPatternTemplate } from "./patterns/dynamic-programming-pattern";
import { ExtendedEuclideanAlgorithmPattern } from "./patterns/extended-euclidean-algorithm";
import { ExponentialSearchPattern } from "./patterns/exponential-search";
import { FastFourierTransformPattern } from "./patterns/fast-fourier-transform";
import { FenwickTreePattern } from "./patterns/fenwick-tree";
import { FibonacciSearchPattern } from "./patterns/fibonacci-search";
import { FloydCycleDetectionPattern } from "./patterns/floyd-cycle-detection";
import { FloydWarshallPattern } from "./patterns/graph-floyd-warshall";
import { BridgesPattern } from "./patterns/graph-bridges";
import { KosarajuPattern } from "./patterns/graph-kosaraju";
import { DijkstraPattern } from "./patterns/dijkstra";
import { ActivitySelectionPattern } from "./patterns/activity-selection.tsx";
import { FractionalKnapsackPattern } from "./patterns/fractional-knapsack.tsx";
import { HuffmanCodingPattern } from "./patterns/huffman-coding.tsx";
import { JobSchedulingPattern } from "./patterns/job-scheduling.tsx";
import { GridTraversalPattern } from "./patterns/grid-traversal";
import { HashTablePattern } from "./patterns/hash-table";
import { HeapImplementationPattern } from "./patterns/heap-implementation";
import { HeapSortPattern } from "./patterns/heap-sort";
import { HeavyLightDecompositionPattern } from "./patterns/heavy-light-decomposition";
import { InsertionSortPattern } from "./patterns/insertion-sort";
import { InterpolationSearchPattern } from "./patterns/interpolation-search";
import { JumpSearchAlgorithmPattern } from "./patterns/jump-search-algorithm";
import { KadanesAlgorithmPattern } from "./patterns/kadanes-algorithm";
import { KnuthMorrisPrattPattern } from "./patterns/kmp-algorithm";
import { KruskalPattern } from "./patterns/greedy-kruskal";
import { LCAPattern } from "./patterns/lca";
import { LinearSearchPattern } from "./patterns/linear-search";
import { LinkedListPattern } from "./patterns/linked-list";
import { ManachersAlgorithmPattern } from "./patterns/manachers-algorithm";
import { MatrixChainMultiplicationPattern } from "./patterns/matrix-chain-multiplication";
import { MatrixExponentiationPattern } from "./patterns/matrix-exponentiation";
import { MatrixOperationsPattern } from "./patterns/matrix-operations";
import { MatrixSpiralTraversalPattern } from "./patterns/matrix-spiral-traversal";
import { MatrixSpiralTraversalRecursivePattern } from "./patterns/matrix-spiral-recursive";
import { MatrixTraversalPattern } from "./patterns/matrix-traversal";
import { MatrixTraversalRecursivePattern } from "./patterns/matrix-traversal-recursive";
import { MaximumBipartiteMatchingPattern } from "./patterns/maximum-bipartite-matching";
import { MemoizationPattern } from "./patterns/memoization";
import { MergeSortPattern } from "./patterns/merge-sort";
import { MillerRabinPrimalityTestPattern } from "./patterns/miller-rabin-primality-test";
import { MonotonicQueuePattern } from "./patterns/monotonic-queue";
import { MonotonicStackPattern } from "./patterns/monotonic-stack";
import { NetworkFlowPattern } from "./patterns/network-flow";
import { PrefixSumsPattern } from "./patterns/prefix-sums";
import { PrimPattern } from "./patterns/prims-algorithm";
import { ProbabilityDPPattern } from "./patterns/probability-dp";
import { QueueImplementationPattern } from "./patterns/queue-implementation";
import { QuickselectPattern } from "./patterns/quickselect";
import { QuickSortPattern } from "./patterns/quick-sort";
import { RabinKarpPattern } from "./patterns/rabin-karp";
import { RedBlackTreePattern } from "./patterns/red-black-tree";
import { RecursionPattern } from "./patterns/recursion";
import { SegmentTreePattern } from "./patterns/segment-tree";
import { SelectionSortPattern } from "./patterns/selection-sort";
import { SieveOfAtkinPattern } from "./patterns/sieve-of-atkin";
import { SieveOfEratosthenesPattern } from "./patterns/sieve-of-eratosthenes";
import { SieveOfSundaramPattern } from "./patterns/sieve-of-sundaram";
import { SlidingWindowPattern } from "./patterns/sliding-window";
import { StackImplementationPattern } from "./patterns/stack-implementation";
import { StackSortPattern } from "./patterns/stack-sort";
import { StateCompressionDPPattern } from "./patterns/state-compression-dp";
import { StringOperationsPattern } from "./patterns/string-operations";
import { StronglyConnectedComponentsPattern } from "./patterns/strongly-connected-components";
import { SuffixArrayPattern } from "./patterns/suffix-array";
import { SuffixTreePattern } from "./patterns/suffix-tree";
import { TernarySearchAlgorithmPattern } from "./patterns/ternary-search-algorithm";
import { TopologicalSortPattern } from "./patterns/topological-sort";
import { TreeDynamicProgrammingPattern } from "./patterns/tree-dp";
import { TrieOperationsPattern } from "./patterns/trie-operations";
import { TwoPointersPattern } from "./patterns/two-pointers";
import { TwoSumDictionaryPattern } from "./patterns/two-sum-dict";
import { TwoSumPattern } from "./patterns/two-sum";
import { TwoSumTwoPointersPattern } from "./patterns/two-sum-two-pointers";
import { UnionFindPattern } from "./patterns/union-find";
import { ZAlgorithmPattern } from "./patterns/z-algorithm";
import { GreedyPattern } from "./patterns/greedy";
import { HungarianPattern } from "./patterns/hungarian";
import { RadixSortPattern } from "./patterns/radix-sort";
import { BitwiseDPPattern } from "./patterns/bitwise-dp";
import { SpanningTreePattern } from "./patterns/spanning-tree";
import { SparseTablePattern } from "./patterns/sparse-table";
import { StringHashingPattern } from "./patterns/string-hashing";
import { ZigzagTraversalPattern } from "./patterns/zigzag-traversal";
import { SortingComparisonsPattern } from "./patterns/sorting-comparisons";
import { PalindromePartitioningPattern } from "./patterns/palindrome-partitioning";
import { LCADFSPattern } from "./patterns/lca-dfs";
import { EditDistancePattern } from "./patterns/edit-distance";
import { FordFulkersonPattern } from "./patterns/ford-fulkerson";
import { KahnTopologicalSortPattern } from "./patterns/kahn-topological-sort";
import { KaratsubaMultiplicationPattern } from "./patterns/karatsuba-multiplication";
import { InorderTraversalPattern } from "./patterns/inorder-traversal";
import { HopcroftKarpPattern } from "./patterns/hopcroft-karp";
import { GraphRepresentationPattern } from "./patterns/graph-representation";
import { TreeImplementationPattern } from "./patterns/tree-implementation";
import { TriePattern } from "./patterns/trie";
import { BucketSortPattern } from "./patterns/bucket-sort";
import { CountingSortPattern } from "./patterns/counting-sort";
import { BinaryIndexedTreePattern } from "./patterns/binary-indexed-tree";
import DoublyLinkedListPattern from "./patterns/doubly-linked-list";
import FastAndSlowPointersPattern from "./patterns/fast-and-slow-pointers";
import FibonacciPattern from "./patterns/fibonacci";
import DFSGraphPattern from "./patterns/dfs-graph";
import { IntervalSchedulingPattern } from "./patterns/interval-scheduling";
import { TestDataPattern } from "./patterns/test-data";

export const pseudocodePatterns: Record<string, () => JSX.Element> = {
  // ===== Graph Algorithms =====
  BFS: BFSPattern,
  "BFS Linked List": BfsLinkedListPattern,
  DFS: DFSPattern,
  "DFS Binary Tree": DfsBinaryTreePattern,
  "DFS Linked List": DfsLinkedListPattern,
  Dijkstra: DijkstraPattern,
  "Bellman-Ford": BellmanFordPattern,
  "Floyd-Warshall": FloydWarshallPattern,
  Kruskal: KruskalPattern,
  Prim: PrimPattern,
  "Topological Sort": TopologicalSortPattern,
  "Strongly Connected Components": StronglyConnectedComponentsPattern,
  "Articulation Points": ArticulationPointsPattern,
  Bridges: BridgesPattern,
  Kosaraju: KosarajuPattern,
  "Maximum Bipartite Matching": MaximumBipartiteMatchingPattern,
  "Network Flow": NetworkFlowPattern,
  "Heavy Light Decomposition": HeavyLightDecompositionPattern,
  "Lowest Common Ancestor": LCAPattern,
  "Ford-Fulkerson": FordFulkersonPattern,
  "Kahn's Topological Sort": KahnTopologicalSortPattern,
  "Hopcroft-Karp": HopcroftKarpPattern,
  "Graph Representation": GraphRepresentationPattern,
  "DFS Graph": DFSGraphPattern,
  "Spanning Tree": SpanningTreePattern,

  // ===== Tree Data Structures =====
  "Binary Search Tree": BinarySearchTreePattern,
  "AVL Tree": AVLTreePattern,
  "Red-Black Tree": RedBlackTreePattern,
  "B Tree": BTreePattern,
  "Segment Tree": SegmentTreePattern,
  "Fenwick Tree": FenwickTreePattern,
  "Suffix Tree": SuffixTreePattern,
  "Trie Operations": TrieOperationsPattern,
  "Tree Implementation": TreeImplementationPattern,
  "LCA DFS": LCADFSPattern,
  "Inorder Traversal": InorderTraversalPattern,
  "Zigzag Traversal": ZigzagTraversalPattern,

  // ===== Dynamic Programming =====
  "Dynamic Programming": DynamicProgrammingPattern,
  "Dynamic Programming Coin Change": DynamicProgrammingCoinChangePattern,
  "Dynamic Programming Iterative": DynamicProgrammingIterativePattern,
  "Dynamic Programming Pattern": DynamicProgrammingPatternTemplate,
  "Digit DP": DigitDPPattern,
  "Probability DP": ProbabilityDPPattern,
  "State Compression DP": StateCompressionDPPattern,
  "Tree DP": TreeDynamicProgrammingPattern,
  "Bitwise DP": BitwiseDPPattern,

  // ===== Greedy Algorithms =====
  Greedy: GreedyPattern,
  "Activity Selection": ActivitySelectionPattern,
  "Fractional Knapsack": FractionalKnapsackPattern,
  "Huffman Coding": HuffmanCodingPattern,
  "Job Scheduling": JobSchedulingPattern,
  "Hungarian Algorithm": HungarianPattern,

  // ===== Search Algorithms =====
  "Linear Search": LinearSearchPattern,
  "Binary Search": BinarySearchPattern,
  "Binary Search on Answer": BinarySearchOnAnswerPattern,
  "Exponential Search": ExponentialSearchPattern,
  "Fibonacci Search": FibonacciSearchPattern,
  "Interpolation Search": InterpolationSearchPattern,
  "Jump Search": JumpSearchAlgorithmPattern,
  "Ternary Search": TernarySearchAlgorithmPattern,

  // ===== Sorting Algorithms =====
  "Bubble Sort": BubbleSortPattern,
  "Insertion Sort": InsertionSortPattern,
  "Selection Sort": SelectionSortPattern,
  "Merge Sort": MergeSortPattern,
  "Quick Sort": QuickSortPattern,
  "Heap Sort": HeapSortPattern,
  "Radix Sort": RadixSortPattern,
  "Stack Sort": StackSortPattern,
  "Sorting Comparisons": SortingComparisonsPattern,
  "Bucket Sort": BucketSortPattern,
  "Counting Sort": CountingSortPattern,

  // ===== Matrix Operations =====
  "Matrix Operations": MatrixOperationsPattern,
  "Matrix Chain Multiplication": MatrixChainMultiplicationPattern,
  "Matrix Exponentiation": MatrixExponentiationPattern,
  "Matrix Spiral Traversal": MatrixSpiralTraversalPattern,
  "Matrix Spiral Recursive": MatrixSpiralTraversalRecursivePattern,
  "Matrix Traversal": MatrixTraversalPattern,
  "Matrix Traversal Recursive": MatrixTraversalRecursivePattern,
  "Grid Traversal": GridTraversalPattern,

  // ===== String Algorithms =====
  "String Operations": StringOperationsPattern,
  "Knuth-Morris-Pratt": KnuthMorrisPrattPattern,
  "Rabin-Karp": RabinKarpPattern,
  "Manacher's Algorithm": ManachersAlgorithmPattern,
  "Z Algorithm": ZAlgorithmPattern,
  "Suffix Array": SuffixArrayPattern,
  "String Hashing": StringHashingPattern,
  "Palindrome Partitioning": PalindromePartitioningPattern,
  "Edit Distance": EditDistancePattern,

  // ===== Number Theory =====
  "Chinese Remainder Theorem": ChineseRemainderTheoremPattern,
  "Extended Euclidean": ExtendedEuclideanAlgorithmPattern,
  "Miller-Rabin Primality Test": MillerRabinPrimalityTestPattern,
  "Sieve of Eratosthenes": SieveOfEratosthenesPattern,
  "Sieve of Atkin": SieveOfAtkinPattern,
  "Sieve of Sundaram": SieveOfSundaramPattern,

  // ===== Data Structures =====
  "Hash Table": HashTablePattern,
  "Linked List": LinkedListPattern,
  "Circular Linked List": CircularLinkedListPattern,
  "Stack Implementation": StackImplementationPattern,
  "Queue Implementation": QueueImplementationPattern,
  "Heap Implementation": HeapImplementationPattern,
  "Union Find": UnionFindPattern,
  "Monotonic Stack": MonotonicStackPattern,
  "Monotonic Queue": MonotonicQueuePattern,
  "Sparse Table": SparseTablePattern,
  "Binary Indexed Tree": BinaryIndexedTreePattern,
  "Doubly Linked List": DoublyLinkedListPattern,
  Trie: TriePattern,

  // ===== Array Techniques =====
  "Two Pointers": TwoPointersPattern,
  "Sliding Window": SlidingWindowPattern,
  "Prefix Sums": PrefixSumsPattern,
  "Kadane's Algorithm": KadanesAlgorithmPattern,
  "Two Sum": TwoSumPattern,
  "Two Sum Dict": TwoSumDictionaryPattern,
  "Two Sum Two Pointers": TwoSumTwoPointersPattern,

  // ===== Miscellaneous =====
  "A* Search": AStarSearchPattern,
  Backtracking: BacktrackingPattern,
  "Bit Manipulation": BitManipulationPattern,
  "Divide and Conquer": DivideAndConquerPattern,
  "Fast Fourier Transform": FastFourierTransformPattern,
  "Floyd Cycle Detection": FloydCycleDetectionPattern,
  Memoization: MemoizationPattern,
  Quickselect: QuickselectPattern,
  Recursion: RecursionPattern,
  "Test Data": TestDataPattern,
  "Karatsuba Multiplication": KaratsubaMultiplicationPattern,
  "Interval Scheduling": IntervalSchedulingPattern,
  "Fast and Slow Pointers": FastAndSlowPointersPattern,
  Fibonacci: FibonacciPattern,
};

// Function to verify pattern consistency
export function verifyPseudocodePatterns() {
  // Get all pattern names
  const patternNames = Object.keys(pseudocodePatterns);

  // Check for duplicate patterns
  const duplicates = patternNames.filter((name, index) => patternNames.indexOf(name) !== index);

  // Check for patterns with similar names (case-insensitive)
  const normalizeName = (name: string) => name.toLowerCase().replace(/[^a-z0-9]/g, "");
  const normalizedNames = new Map(patternNames.map((name) => [normalizeName(name), name]));
  const similarNames = new Set<string>();

  patternNames.forEach((name) => {
    const normalized = normalizeName(name);
    const existing = normalizedNames.get(normalized);
    if (existing && existing !== name) {
      similarNames.add(`${name} vs ${existing}`);
    }
  });

  // Check for patterns that might be in wrong categories
  const categoryPatterns = new Map<string, string[]>();
  patternNames.forEach((name) => {
    const pattern = pseudocodePatterns[name]();
    const category = pattern.props.category;
    if (!categoryPatterns.has(category)) {
      categoryPatterns.set(category, []);
    }
    categoryPatterns.get(category)?.push(name);
  });

  // Log results
  console.log("\nPseudocode Pattern Verification Results:");
  console.log("--------------------------------------");

  if (duplicates.length > 0) {
    console.log("\nDuplicate patterns found:");
    duplicates.forEach((p) => console.log(`- ${p}`));
  }

  if (similarNames.size > 0) {
    console.log("\nPatterns with similar names:");
    Array.from(similarNames).forEach((p) => console.log(`- ${p}`));
  }

  // Log patterns by category
  console.log("\nPatterns by category:");
  console.log("-------------------");
  for (const [category, patterns] of categoryPatterns) {
    console.log(`\n${category}:`);
    patterns.forEach((p) => console.log(`- ${p}`));
  }

  // Summary statistics
  console.log("\nSummary:");
  console.log("--------");
  console.log(`Total patterns: ${patternNames.length}`);
  console.log(`Total categories: ${categoryPatterns.size}`);
  console.log(`Duplicate patterns: ${duplicates.length}`);
  console.log(`Similar names: ${similarNames.size}`);

  return {
    totalPatterns: patternNames.length,
    duplicates,
    similarNames: Array.from(similarNames),
    categories: Object.fromEntries(categoryPatterns),
    stats: {
      categoryCount: categoryPatterns.size,
      duplicateCount: duplicates.length,
      similarNameCount: similarNames.size,
    },
  };
}

// Function to verify patterns against pattern files
export function verifyPatternFiles() {
  // Get all pattern names from pseudocodePatterns
  const pseudocodeNames = Object.keys(pseudocodePatterns);

  // Get all pattern names from the patterns directory
  const patternFiles = new Map<string, string[]>();
  const patternCategories = new Map<string, string[]>();
  const missingImplementations = new Map<string, { pattern: string; expectedPaths: string[] }[]>();
  const implementationDetails = new Map<
    string,
    { category: string; filePath: string; exists: boolean }
  >();

  // Check each pattern's implementation
  pseudocodeNames.forEach((name) => {
    const pattern = pseudocodePatterns[name]();
    const category = pattern.props.category;

    // Add to category map
    if (!patternCategories.has(category)) {
      patternCategories.set(category, []);
    }
    patternCategories.get(category)?.push(name);

    // Check if pattern file exists
    const normalizedName = name?.toLowerCase().replace(/[^a-z0-9]/g, "-") || "";
    const possiblePaths = [
      `patterns/${category?.toLowerCase() || ""}/${normalizedName}.ts`,
      `patterns/${category?.toLowerCase() || ""}/${normalizedName}.tsx`,
      `patterns/${category?.toLowerCase() || ""}/index.ts`,
      `patterns/${category?.toLowerCase() || ""}/index.tsx`,
    ];

    const foundPaths: string[] = [];
    const exists = possiblePaths.some((path) => {
      try {
        require.resolve(`../../components/algorithm-trainer/${path}`);
        foundPaths.push(path);
        patternFiles.set(name, foundPaths);
        return true;
      } catch {
        return false;
      }
    });

    // Store implementation details
    implementationDetails.set(name, {
      category,
      filePath: foundPaths[0] || possiblePaths[0],
      exists,
    });

    if (!exists) {
      if (!missingImplementations.has(category)) {
        missingImplementations.set(category, []);
      }
      missingImplementations.get(category)?.push({
        pattern: name,
        expectedPaths: possiblePaths,
      });
    }
  });

  // Check for patterns in files but not in pseudocodePatterns
  const allPatternFiles = new Map<string, { name: string; file: string }[]>();
  const categoryDirs = [
    "array",
    "backtracking",
    "data-structures",
    "divide-and-conquer",
    "dynamic-programming",
    "greedy",
    "tree",
    "string",
    "searching",
    "sorting",
    "number-theory",
    "matrix",
    "graph",
    "recursion",
  ];

  categoryDirs.forEach((dir) => {
    try {
      const files = require(`../../components/algorithm-trainer/patterns/${dir}`);
      Object.keys(files).forEach((key) => {
        if (key.endsWith("Patterns")) {
          const patterns = files[key];
          Object.keys(patterns).forEach((patternName) => {
            if (!allPatternFiles.has(dir)) {
              allPatternFiles.set(dir, []);
            }
            allPatternFiles.get(dir)?.push({
              name: patternName,
              file: key,
            });
          });
        }
      });
    } catch (e) {
      console.warn(`Warning: Could not load patterns from ${dir} directory`);
    }
  });

  // Find patterns in files but not in pseudocodePatterns
  const missingInPseudocode = new Map<string, { name: string; file: string }[]>();
  for (const [dir, patterns] of allPatternFiles) {
    const missing = patterns.filter(({ name }) => !pseudocodeNames.includes(name));
    if (missing.length > 0) {
      missingInPseudocode.set(dir, missing);
    }
  }

  // Log results
  console.log("\nPattern File Verification Results:");
  console.log("=================================");

  // Implementation Status
  console.log("\nImplementation Status:");
  console.log("---------------------");
  for (const [category, patterns] of patternCategories) {
    console.log(`\n${category}:`);
    patterns.forEach((name) => {
      const details = implementationDetails.get(name);
      if (details) {
        console.log(`- ${name}`);
        console.log(`  File: ${details.filePath}`);
        console.log(`  Status: ${details.exists ? "✓ Implemented" : "✗ Missing"}`);
      }
    });
  }

  if (missingImplementations.size > 0) {
    console.log("\nPatterns Missing Implementation Files:");
    console.log("-----------------------------------");
    for (const [category, patterns] of missingImplementations) {
      console.log(`\n${category}:`);
      patterns.forEach(({ pattern, expectedPaths }) => {
        console.log(`- ${pattern}`);
        console.log(`  Expected in one of:`);
        expectedPaths.forEach((path) => console.log(`    ${path}`));
      });
    }
  }

  if (missingInPseudocode.size > 0) {
    console.log("\nPatterns in Files but Missing in pseudocodePatterns:");
    console.log("------------------------------------------------");
    for (const [dir, patterns] of missingInPseudocode) {
      console.log(`\n${dir}:`);
      patterns.forEach(({ name, file }) => {
        console.log(`- ${name}`);
        console.log(`  Found in: ${file}`);
      });
    }
  }

  // Category Analysis
  console.log("\nCategory Analysis:");
  console.log("----------------");
  for (const [category, patterns] of patternCategories) {
    const implemented = patterns.filter((name) => implementationDetails.get(name)?.exists);
    const missing = patterns.filter((name) => !implementationDetails.get(name)?.exists);
    console.log(`\n${category}:`);
    console.log(`  Total Patterns: ${patterns.length}`);
    console.log(`  Implemented: ${implemented.length}`);
    console.log(`  Missing: ${missing.length}`);
    if (missing.length > 0) {
      console.log(`  Missing Patterns:`);
      missing.forEach((p) => console.log(`    - ${p}`));
    }
  }

  // Summary statistics
  console.log("\nSummary Statistics:");
  console.log("-----------------");
  console.log(`Total patterns in pseudocodePatterns: ${pseudocodeNames.length}`);
  console.log(`Total patterns in files: ${Array.from(allPatternFiles.values()).flat().length}`);
  console.log(
    `Patterns missing implementation files: ${Array.from(missingImplementations.values()).flat().length}`
  );
  console.log(
    `Patterns missing in pseudocodePatterns: ${Array.from(missingInPseudocode.values()).flat().length}`
  );
  console.log(`Total categories: ${patternCategories.size}`);

  // Implementation coverage
  const totalImplemented = Array.from(implementationDetails.values()).filter(
    (d) => d.exists
  ).length;
  const coverage = ((totalImplemented / pseudocodeNames.length) * 100).toFixed(1);
  console.log(`\nImplementation Coverage: ${coverage}%`);

  return {
    totalPseudocodePatterns: pseudocodeNames.length,
    totalFilePatterns: Array.from(allPatternFiles.values()).flat().length,
    missingImplementations: Object.fromEntries(missingImplementations),
    missingInPseudocode: Object.fromEntries(missingInPseudocode),
    categories: Object.fromEntries(patternCategories),
    implementationDetails: Object.fromEntries(implementationDetails),
    stats: {
      categoryCount: patternCategories.size,
      missingImplementationCount: Array.from(missingImplementations.values()).flat().length,
      missingInPseudocodeCount: Array.from(missingInPseudocode.values()).flat().length,
      coverage: parseFloat(coverage),
    },
  };
}

// Run both verifications
verifyPseudocodePatterns();
verifyPatternFiles();
